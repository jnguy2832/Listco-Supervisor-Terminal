<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Listco Break Portal</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"/>
  <link rel="icon" href="/static/logo.png">
  <style>
    body {
      background-color: #fff8f0;
      font-family: 'Segoe UI', 'Roboto', sans-serif;
    }
    .menu-header {
      background-color: rgb(255, 240, 173);
      color: rgb(90, 66, 150);
      padding: 1rem;
      text-align: center;
      border-bottom: 2px solid rgb(90, 66, 150);
    }
    .menu-header img {
      width: 240px;
      height: auto;
      margin-bottom: 0.5rem;
    }
    .menu-header h3 {
      font-weight: 800;
      font-size: 1.5rem;
      margin: 0;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .dashboard-link {
      margin: 1rem;
    }
    .tracker-section {
      background-color: white;
      margin: 1rem;
      padding: 1rem;
      border-radius: 0.5rem;
      box-shadow: 0 0 10px rgba(0,0,0,0.05);
    }
    .tracker-header {
      display: flex;
      justify-content: space-between;
      margin-bottom: 1rem;
      flex-wrap: wrap;
      gap: 1rem;
      align-items: center;
    }
    .tracker-header select {
      width: 200px;
    }
    .tracker-table th, .tracker-table td {
      text-align: center;
      vertical-align: middle;
      font-size: 0.9rem;
      padding: 0.5rem;
    }
    .tracker-table th {
      background-color: rgb(255, 243, 200);
      color: rgb(90, 66, 150);
    }
    .employee-name {
      font-weight: 600;
    }
    details summary {
      cursor: pointer;
      color: #944ec2;
    }
    .status-class {
      display: inline-block;
      padding: 4px 12px;
      border-radius: 12px;
      font-size: .75rem;
      font-weight: bold;
      text-transform: uppercase;
    }
    .status-class.on-break {
      background-color: white;
      color: white;
    }
    .status-class.ending-soon {
      background-color: orange;
      color: white;
    }
    .status-class.over {
      background-color: red;
      color: white;
    }

    /* Styling for horizontal date/day/time */
    .current-datetime {
      display: flex;
      flex-wrap: wrap;           /* Wraps to next line on smaller screens */
      gap: 1.5rem;
      font-weight: 600;
      color: rgb(90, 66, 150);   /* matches website theme */
      justify-content: flex-start;
    }
    .current-datetime div {
      min-width: 120px;          /* ensures each block has enough space */
      white-space: nowrap;       /* prevents breaking inside the text */
    }
    .current-datetime div strong {
      color: rgb(90, 66, 150);
    }

  .status-class {
    display: inline-block;
    padding: 4px 10px;
    border-radius: 12px;
    font-size: .75rem;
    font-weight: 700;
    text-transform: uppercase;
    color: #fff;
    margin-right: .5rem;
  }
  .status-class.on-break      { background: purple; } 
  .status-class.ending-soon   { background: orange; } 
  .status-class.over          { background: orangered; } 
  .status-class.missed        { background: red; } 
  .status-class.assigned      { background: lightskyblue; } 

  .row-on-break {
    background-color: #b7f6c1 !important;
  }
  .row-ending-soon {
    background-color: #fdbc99 !important;
  }
  .row-over {
    background-color: #f59393 !important;
  }
  .row-missed {
    background-color: #f85252 !important;
  }
  .row-assigned {
    background-color: white !important;
  }
  </style>
</head>
<body onload="updateCurrentDateTime()">

  <div class="menu-header">
    <img src="/static/logo.png" alt="Listco Logo" />
    <h3>Listco Break Portal</h3>
  </div>

  <div class="dashboard-link text-start">
    <a href="/" class="btn btn-outline-primary">Back to Dashboard</a>
  </div>

  <div class="tracker-section">
    <div class="tracker-header w-100">
      <!-- Replaced Month/Week dropdowns with horizontal date/day/time -->
      <div class="current-datetime">
        <div><strong>Date:</strong> <span id="currentDate"></span></div>
        <div><strong>Day:</strong> <span id="currentDay"></span></div>
        <div><strong>Time:</strong> <span id="currentTime"></span></div>
      </div>
      <div class="ms-auto">
        <span id="connectionStatus" class="connection-status status-disconnected">Disconnected</span>
      </div>
    </div>

    <div class="table-responsive">
      <table class="table table-bordered table-striped tracker-table">
        <thead>
          <tr>
            <th>Employee</th>
            <th>Date</th>
            <th>Start Shift</th>
            <th>End Shift</th>
            <th>Location</th>
            <th>Break Timeframe(s)</th>
          </tr>
        </thead>
        <tbody id="trackerBody"></tbody>
      </table>
    </div>
  </div>

  <script>
    // New function to update live date/day/time in AM/PM format
    function updateCurrentDateTime() {
      const now = new Date();
      const optionsDate = { month: 'short', day: 'numeric', year: 'numeric' };
      const optionsDay = { weekday: 'long' };

      document.getElementById('currentDate').textContent = now.toLocaleDateString(undefined, optionsDate);
      document.getElementById('currentDay').textContent = now.toLocaleDateString(undefined, optionsDay);
      document.getElementById('currentTime').textContent = now.toLocaleTimeString(undefined, { hour: 'numeric', minute: '2-digit', second: '2-digit', hour12: true });
    }

    setInterval(updateCurrentDateTime, 1000);
    updateCurrentDateTime();

    function getWeekRange(startDate) {
      const sunday = new Date(startDate);
      const saturday = new Date(sunday);
      saturday.setDate(sunday.getDate() + 6);
      const options = { month: '2-digit', day: '2-digit', year: 'numeric' };
      return `${sunday.toLocaleDateString('en-US', options)} to ${saturday.toLocaleDateString('en-US', options)}`;
    }

    function populateMonthDropdown() {
      const monthSelector = document.getElementById("monthSelector");
      const today = new Date();
      const currentYear = today.getFullYear();
      monthSelector.innerHTML = "";

      for (let m = 0; m <= 11; m++) {
        const date = new Date(currentYear, m, 1);
        const label = date.toLocaleString('en-US', { month: 'long' });
        const option = document.createElement("option");
        option.value = m;
        option.textContent = label;
        if (m === today.getMonth()) option.selected = true;
        monthSelector.appendChild(option);
      }

      updateWeekOptions();
    }

    function updateWeekOptions() {
      const month = parseInt(document.getElementById("monthSelector").value);
      const weekSelector = document.getElementById("weekSelector");
      weekSelector.innerHTML = "";

      const today = new Date();
      const year = today.getFullYear();
      const firstDay = new Date(year, month, 1);
      const lastDay = new Date(year, month + 1, 0);

      let sunday = new Date(firstDay);
      sunday.setDate(sunday.getDate() - sunday.getDay());

      while (sunday <= lastDay) {
        const label = getWeekRange(sunday);
        const option = document.createElement("option");
        option.value = label;
        option.textContent = label;
        weekSelector.appendChild(option);
        sunday.setDate(sunday.getDate() + 7);
      }

      updateSelectedWeek();
    }

    function updateSelectedWeek() {
      const selectedMonth = parseInt(document.getElementById("monthSelector").value);
      const trackerBody = document.getElementById("trackerBody");
      trackerBody.innerHTML = "";

      const entries = []; // Supervisor will populate this manually or via backend

      entries.forEach(entry => {
        const entryDate = new Date(entry.date);
        if (entryDate.getMonth() === selectedMonth) {
          const breakDetails = entry.breaks.map(b => `• ${b.inTime} – ${b.outTime}`).join("<br>");

          const row = document.createElement("tr");
          row.innerHTML = `
            <td><div class="employee-name">${entry.name}</div></td>
            <td>${entry.date}</td>
            <td>${entry.start}</td>
            <td>${entry.end}</td>
            <td>${entry.location}</td>
            <td>
              <details>
                <summary>View Breaks Taken</summary>
                <div class="text-start mt-1">${breakDetails}</div>
              </details>
            </td>
          `;
          trackerBody.appendChild(row);
        }
      });
    }

    // Construct WebSocket URL from the page origin. This avoids accidental
    // concatenation of host/path when the page is served under a subpath.
    console.log('Location debug:', {
      href: window.location.href,
      origin: window.location.origin,
      host: window.location.host,
      hostname: window.location.hostname,
      port: window.location.port,
      pathname: window.location.pathname
    });

    function buildWsUrl(path) {
      const origin = window.location.origin || (window.location.protocol + '//' + window.location.host);
      let wsOrigin = origin.replace(/^http/, 'ws');
      let full = wsOrigin.replace(/\/$/, '') + '/' + path.replace(/^\//, '');
      full = full.replace(/([^:]\/\/)\/+/g, '$1');
      return full;
    }

    const wsUrl = buildWsUrl('/ws/breaks/');
    console.log('WebSocket URL ->', wsUrl);
    let breakSocket = null;
    let reconnectAttempts = 0;
    const maxReconnectAttempts = 5;

    function connectWebSocket(){
      breakSocket = new WebSocket(wsUrl);

      breakSocket.onopen = function(e) {
        console.log('WebSocket connected');
        reconnectAttempts = 0;
        updateConnectionStatus(true);
      };

      breakSocket.onmessage = function(e) {
          const data = JSON.parse(e.data);
          console.log('Received: ', data);

          if (data.type === 'initial_data' || data.type === 'breaks_update') {
            renderBreaksTable(data.breaks);
          } else if (data.type === 'break_update') {
            updateSingleBreak(data);
          }
      };

      breakSocket.onclose = function(e) {
        console.log('WebSocket disconnected');
        updateConnectionStatus(false);

        if (reconnectAttempts < maxReconnectAttempts) {
          reconnectAttempts++;
          setTimeout(() => {
            console.log(`Reconnecting... Attempt ${reconnectAttempts}`);
            connectWebSocket();
          }, 3000);
        }
      };
      breakSocket.onerror = function(error) {
        console.error('WebSocket error: ', error);
      };
    }

    function updateConnectionStatus(connected) {
      const statusEl = document.getElementById('connectionStatus');
      if (connected) {
        statusEl.textContent = 'Connected';
        statusEl.className = 'connection-status status-connected';
      } else {
        statusEl.textContent = 'Disconnected';
        statusEl.className = 'connection-status status-disconnected';
      }
    }

    function formatTime(dateString) {
      if (!dateString) return '';
      const date = new Date(dateString);
      return date.toLocaleTimeString('en-US', {hour: 'numeric', minute: '2-digit', hour12: true});
    }

    function formatDate(dateString) {
      if (!dateString) return '';
      const date = new Date(dateString);
      return date.toLocaleDateString('en-US', {month: 'short', day: 'numeric', year: 'numeric'});
    }

    function getBreakTypeDisplay(breakType) {
      return breakType === 'M30' ? '30 minute meal' : '15 minute break';
    }

    function renderBreaksTable(breaks) {
      const tbody = document.getElementById('trackerBody');

      if (!breaks || breaks.length === 0) {
        tbody.innerHTML = '<tr><td colspan="6" class="text-center text-muted">No Shifts Scheduled Today</td></tr>'
        return;
      }

      const shiftsMap = new Map();
      breaks.forEach(breakObj => {
        const key = breakObj.employee_name;
        if (!shiftsMap.has(key)) {
          shiftsMap.set(key, {
            employee_name: breakObj.employee_name,
            breaks: []
          });
        }
        shiftsMap.get(key).breaks.push(breakObj);
      });

      let html = '';
      shiftsMap.forEach((shiftData, employee_name) => {
      const hasOnBreak = shiftData.breaks.some(b => b.status === 'On Break');
      const hasFiveLeft = shiftData.breaks.some(b => b.status === '5 minutes left');
      const hasOver = shiftData.breaks.some(b => b.status === 'Over break time');
      const hasMissed = shiftData.breaks.some(b => b.status === 'Missed break return');
      const hasAssignedOnly = !hasOnBreak && !hasFiveLeft && !hasMissed && !hasOver && shiftData.breaks.some(b => b.status === 'Assigned');

      let rowClass = '';
      if (hasOnBreak) rowClass = 'row-on-break';
      else if (hasFiveLeft) rowClass = 'row-ending-soon';
      else if (hasOver) rowClass = 'row-over';
      else if (hasMissed) rowClass = 'row-missed';
      else if (hasAssignedOnly) rowClass = 'row-assigned';

        const firstBreak = shiftData.breaks[0] || {};
        const employeeName = shiftData.employee_name || employee_name;

        html += `
          <tr class="${rowClass}">
            <td>
              <div class="employee-name">${employeeName}</div>
            </td>
            <td>${firstBreak.shift_start ? formatDate(firstBreak.shift_start) : (firstBreak.break_start ? formatDate(firstBreak.break_start) : '')}</td>
            <td>${firstBreak.shift_start ? formatTime(firstBreak.shift_start) : (firstBreak.break_start ? formatTime(firstBreak.break_start) : '')}</td>
            <td>${firstBreak.shift_end ? formatTime(firstBreak.shift_end) : (firstBreak.break_end ? formatTime(firstBreak.break_end) : '')}</td>
            <td>${firstBreak.location || ''}</td>
            <td>`;
        if (shiftData.breaks.length > 0) {
          shiftData.breaks.forEach(b => {
            html += renderBreakItem(b);
          });
        } else {
          html += '<div class="text-muted">No breaks scheduled</div>';
        }
        html += `
            </td>
          </tr>`;
      });

      tbody.innerHTML = html;
    }

    function renderBreakItem(breakObj) {
      let statusBadge = '';
      let actionButton = '';
      
      if (breakObj.status === 'On Break') {
        statusBadge = '<span class="status-class on-break">On Break</span>';
      } else if (breakObj.status === '5 minutes left') {
        statusBadge = '<span class="status-class ending-soon">5 minutes left</span>';
        actionButton = 
        `<button class="btn btn-sm" onclick="endBreak(${breakObj.id})">
          End Break
        </button>`;
      } else if (breakObj.status === 'Over break time') {
        statusBadge = '<span class="status-class over">Late to return</span>';
        actionButton = 
        `<button class="btn btn-sm btn-outline-success" onclick="endBreak(${breakObj.id})">
          End Break
        </button>`;
      } else if (breakObj.status === 'Missed break return') {
        statusBadge = '<span class="status-class missed">Did not return from break</span>';
        actionButton = 
        `<button class="btn btn-sm btn-outline-success" onclick="endBreak(${breakObj.id})">
          End Break
        </button>`;
      } else if (breakObj.status === 'Assigned') {
        statusBadge = '<span class="status-class assigned">Assigned</span>';
        actionButton = 
        `<button class="btn btn-sm btn-primary" onclick="startBreak(${breakObj.id})">
          Start Break
        </button>`;
      } else if (breakObj.status === 'Over') {
        statusBadge = '<span class="badge bg-success">Complete</span>';
      } else {
        statusBadge = `<span class="badge bg-secondary">${breakObj.status}</span>`;
      }

      return `
        <div class="mb-2 p-2 border rounded" data-break-id="${breakObj.id}">
          <div>
            <strong>${getBreakTypeDisplay(breakObj.break_type)}</strong>
            ${breakObj.break_start ? ` - ${formatTime(breakObj.break_start)}` : ''}
            ${breakObj.break_end ? ` to ${formatTime(breakObj.break_end)}` : ''}
          </div>
          <div class="mt-1">
            ${statusBadge}
            ${actionButton}
          </div>
        </div>`;
    }

    function updateSingleBreak(data) {
      const breakEl = document.querySelector(`[data-break-id="${data.break_id}"]`);
      if (breakEl) {
        const breakObj = {
          id: data.break_id,
          break_type: data.break_type || breakEl.getAttribute('data-break-type') || 'R15',
          break_start: data.break_start,
          break_end: data.break_end,
          status: data.status
        };
        breakEl.outerHTML = renderBreakItem(breakObj);
        
        updateRowBackground(data.employee_name || breakEl.closest('tr').querySelector('.employee-name').textContent);
      } else {
        requestUpdate();
      }
    }
    function updateRowBackground(employeeName) {
        const allRows = document.querySelectorAll('tr');
        let targetRow = null;
        
        for (const row of allRows) {
          const nameEl = row.querySelector('.employee-name');
          if (nameEl && nameEl.textContent === employeeName) {
            targetRow = row;
            break;
          }
        }
        
        if (!targetRow) return;
        
        // Find all breaks in this specific row
        const allBreaks = Array.from(targetRow.querySelectorAll('[data-break-id]'))
          .map(el => {
            const statusEl = el.querySelector('.status-class');
            return statusEl ? statusEl.textContent : '';
          });

        // Determine row class based on break statuses
        const allBadges = Array.from(targetRow.querySelectorAll('.status-class'));

        const hasOnBreak = allBadges.some(el => el.classList.contains('on-break'));
        const hasFiveLeft = allBadges.some(el => el.classList.contains('ending-soon'));
        const hasOver = allBadges.some(el => el.classList.contains('over'));
        const hasMissed = allBadges.some(el => el.classList.contains('missed'));
        const hasAssigned = allBadges.some(el => el.classList.contains('assigned'));

        let rowClass = '';
        if (hasOnBreak) rowClass = 'row-on-break';
        else if (hasFiveLeft) rowClass = 'row-ending-soon';
        else if (hasOver) rowClass = 'row-over';
        else if (hasMissed) rowClass = 'row-missed';
        else if (hasAssigned && !hasOnBreak && !hasFiveLeft && !hasOver && !hasMissed) rowClass = 'row-assigned';

        // 1. Remove all existing row classes
        targetRow.classList.remove('row-on-break', 'row-ending-soon', 'row-over', 'row-missed', 'row-assigned');

        // 2. Apply the new class
        if (rowClass) {
            targetRow.classList.add(rowClass);
        }
    }

    function requestUpdate() {
      if (breakSocket && breakSocket.readyState === WebSocket.OPEN) {
        breakSocket.send(JSON.stringify({type: 'update'}));
      }
    }

    function startBreak(breakId) {
      fetch(window.location.href, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
          'X-CSRFToken': getCookie('csrftoken')
        },
        body: `action=start_break&break_id=${breakId}`
      }).then(() => {
        requestUpdate()
      });
    }

    function endBreak(breakId) {
      fetch(window.location.href, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
          'X-CSRFToken': getCookie('csrftoken')
        },
        body: `action=end_break&break_id=${breakId}`
      }).then(() => {
        requestUpdate()
      });
    }

    function getCookie(name) {
      let cookieValue = null;
      if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
          const cookie = cookies[i].trim();
          if (cookie.substring(0, name.length+1)===(name + '=')) {
            cookieValue = decodeURIComponent(cookie.substring(name.length+1));
            break;
          }
        }
      }
      return cookieValue;
    }

    connectWebSocket();
    setInterval(requestUpdate, 30000);
  </script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>